#!/usr/bin/env python
# Software License Agreement (BSD License)
#
# Copyright (c) 2009, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

## ROS message source code generation for C++
## 
## Converts ROS .msg files in a package into C++ source code implementations.

from __future__ import print_function

from genmsg import log, plog

import genmsg_cpp
 
import sys
import os
import traceback

import genmsg.srvs
import genmsg.gentools

try:
    from cStringIO import StringIO # Python 2.x
except ImportError:
    from io import StringIO # Python 3.x

def write_begin(s, spec, file):
    """
    Writes the beginning of the header file: a comment saying it's auto-generated and the include guards
    
    :param s: The stream to write to, ``stream``
    :param spec: The :class:`genmsg.SrvSpec` spec
    :param file: The file this service is being generated for, ``str``
    """
    s.write("/* Auto-generated by genmsg_cpp for file %s */\n"%(file))
    s.write('#ifndef %s_SERVICE_%s_H\n'%(spec.package.upper(), spec.short_name.upper()))
    s.write('#define %s_SERVICE_%s_H\n'%(spec.package.upper(), spec.short_name.upper()))

def write_end(s, spec):
    """
    Writes the end of the header file: the ending of the include guards
    
    :param s: The stream to write to, ``stream``
    :param spec: The :class:`genmsg.SrvSpec` spec
    """
    s.write('#endif // %s_SERVICE_%s_H\n'%(spec.package.upper(), spec.short_name.upper()))
    
def write_generic_includes(s):
    """
    Writes the includes that all service need
    
    :param s: The stream to write to, ``stream``
    """
    s.write('#include "ros/service_traits.h"\n\n')
    
def write_trait_char_class(s, class_name, cpp_msg, value):
    """
    Writes a class trait for traits which have static value() members that return const char*
    
    e.g. write_trait_char_class(s, "MD5Sum0", "std_srvs::Empty", "hello") yields:
    template<>
    struct MD5Sum<std_srvs::Empty> 
    {
        static const char* value() { return "hello"; }
        static const char* value(const std_srvs::Empty&) { return value(); }
    };
    
    :param s: The stream to write to, ``stream``
    :param class_name: The name of the trait class, ``str``
    :param cpp_msg: The C++ message declaration, e.g. "std_srvs::Empty", ``str``
    :param value: The string value to return from the value() function
    """
    s.write('template<>\nstruct %s<%s> {\n'%(class_name, cpp_msg))
    s.write('  static const char* value() \n  {\n    return "%s";\n  }\n\n'%(value))
    s.write('  static const char* value(const %s&) { return value(); } \n'%(cpp_msg))
    s.write('};\n\n')
    
def write_traits(s, spec, cpp_name_prefix, includepath):
    """
    Write all the service traits for a message
    
    :param s: The stream to write to, ``stream``
    :param spec: The :class:`SrvSpec` service spec
    :param cpp_name_prefix: The C++ prefix to prepend when referencing the service, e.g. "std_srvs::", ``str``
    """
    gendeps_dict = genmsg.gentools.get_dependencies(spec, spec.package, includepath)
    md5sum = genmsg.gentools.compute_md5(gendeps_dict, includepath)
    
    s.write('namespace ros\n{\n')
    s.write('namespace service_traits\n{\n')
    
    request_with_allocator = '%s%s_<ContainerAllocator> '%(cpp_name_prefix, spec.request.short_name)
    response_with_allocator = '%s%s_<ContainerAllocator> '%(cpp_name_prefix, spec.response.short_name)
    
    write_trait_char_class(s, 'MD5Sum', '%s%s'%(cpp_name_prefix, spec.short_name), md5sum);
    write_trait_char_class(s, 'DataType', '%s%s'%(cpp_name_prefix, spec.short_name), spec.full_name);
    genmsg_cpp.write_trait_char_class(s, 'MD5Sum', request_with_allocator, md5sum)
    genmsg_cpp.write_trait_char_class(s, 'DataType', request_with_allocator, spec.full_name)
    genmsg_cpp.write_trait_char_class(s, 'MD5Sum', response_with_allocator, md5sum)
    genmsg_cpp.write_trait_char_class(s, 'DataType', response_with_allocator, spec.full_name)
    s.write('} // namespace service_traits\n')
    s.write('} // namespace ros\n\n')

def generate(srv_path, options):
    """
    Generate a service
    
    @param srv_path: the path to the .srv file
    @type srv_path: str
    """

    import em

    #todo use an external templatefile

    template_str = """
/* Auto-generated by gensrv_cpp for file @file_name_in */
#ifndef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H
#define @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H

#include <ros/service_traits.h>

@{
import genmsg_cpp

for l in genmsg_cpp.generator(spec.request, "somefile", "ABC"):
    print(l)

for l in genmsg_cpp.generator(spec.response, "somefile", "ABC"):
    print(l)


cpp_namespace = '::'+spec.package+'::' # TODO handle nested namespace                                                                   
cpp_class = spec.short_name
cpp_full_name = cpp_namespace+cpp_class

}@

@######################
@#  Service Struct
@######################

namespace @(package)
{

struct @(spec.short_name)
{

typedef @(spec.request.short_name) Request;
typedef @(spec.response.short_name) Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;

}; // struct @(spec.short_name)
} // namespace @(package)



@######################
@# Service-Traits
@######################

namespace ros
{
namespace service_traits
{

@[for trait_class,trait_value in [['MD5Sum', md5sum], ['DataType', spec.full_name]] ]
template<>
struct @trait_class< @cpp_full_name > {
  static const char* value()
  {
    return "@(trait_value)";
  }

  static const char* value(const @(cpp_full_name)&) { return value(); }
};
@[end for]

} // namespace service_traits
} // namespace ros

#endif // @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H

"""
    infile = os.path.abspath(srv_path)
    msg_context = genmsg.msg_loader.MsgContext.create_default()
    full_type_name = genmsg.gentools.compute_full_type_name(options.package, os.path.basename(infile))
    print(full_type_name, infile)
    spec = genmsg.msg_loader.load_srv_from_file(msg_context, infile, full_type_name)

    search_path = genmsg.command_line.includepath_to_dict(options.includepath)
    try:
        genmsg.msg_loader.load_depends(msg_context, spec, search_path)
    except genmsg.InvalidMsgSpec as e:
        raise genmsg.MsgGenerationException("Cannot read .msg for %s: %s"%(full_type_name, str(e)))

    out_file_name = os.path.join(options.outdir, spec.short_name + ".h")
    ofile = open(out_file_name, 'w')
    print (out_file_name)


    md5sum = genmsg.compute_md5(msg_context, spec)

    g={
        "package":options.package,
        "file_name_in":infile,
        "spec":spec,
        "md5sum":md5sum}

    interpreter = em.Interpreter(output=ofile, globals=g, options={"rawErrors_OPT":True})
    interpreter.string(template_str)
    #interpreter.file(open('/path/to/some/file'))
    interpreter.shutdown()

    return

    s = StringIO()  
    cpp_prefix = '%s::'%(options.package)
    write_begin(s, spec, srv_path)
    genmsg_cpp.write_generic_includes(s)
    write_generic_includes(s)
    genmsg_cpp.write_includes(s, spec.request)
    s.write('\n')
    genmsg_cpp.write_includes(s, spec.response)
    
    gendeps_dict = genmsg.gentools.get_dependencies(spec, spec.package,
                                                    options.includepath)

    md5sum = genmsg.gentools.compute_md5(gendeps_dict, options.includepath)
    
    s.write('namespace %s\n{\n'%(options.package))
    genmsg_cpp.write_struct(s, spec.request, cpp_prefix, {'ServerMD5Sum': md5sum})
    s.write('\n')
    genmsg_cpp.write_struct(s, spec.response, cpp_prefix, {'ServerMD5Sum': md5sum})
    s.write('struct %s\n{\n'%(spec.short_name))
    s.write('\n')
    s.write('typedef %s Request;\n'%(spec.request.short_name))
    s.write('typedef %s Response;\n'%(spec.response.short_name))
    s.write('Request request;\n')
    s.write('Response response;\n\n')
    s.write('typedef Request RequestType;\n')
    s.write('typedef Response ResponseType;\n')
    s.write('}; // struct %s\n'%(spec.short_name))
    s.write('} // namespace %s\n\n'%(options.package))
    
    request_cpp_name = "Request"
    response_cpp_name = "Response"
    log("options.includepath", str(options.includepath))
    genmsg_cpp.write_traits(s, spec.request, cpp_prefix, options.includepath)
    s.write('\n')
    genmsg_cpp.write_traits(s, spec.response, cpp_prefix, options.includepath)
    genmsg_cpp.write_serialization(s, spec.request, cpp_prefix)
    s.write('\n')
    genmsg_cpp.write_serialization(s, spec.response, cpp_prefix)
    
    write_traits(s, spec, cpp_prefix, options.includepath)
    
    write_end(s, spec)
    
    if 'ROS_BUILD' in os.environ:
        package_dir = os.environ['ROS_BUILD']
    output_dir = os.path.join(options.outdir, options.package)
    if (not os.path.exists(output_dir)):
        # if we're being run concurrently, the above test can report false but os.makedirs can still fail if
        # another copy just created the directory
        try:
            os.makedirs(output_dir)
        except OSError as e:
            pass
        
    ofile = os.path.join(output_dir, spec.short_name + ".h")
    with open(ofile, 'w') as f:
        print("Writing to", ofile)
        print(s.getvalue(), file=f)
    
    s.close()

def generate_services(argv):
    # print argv
    from optparse import OptionParser
    parser = OptionParser("gencpp_srv.py [options] <srv file>")
    parser.add_option("-p", dest='package',
                      help="package name")

    parser.add_option("-o", dest='outdir',
                      help="directory in which to place output files")

    parser.add_option("-I", dest='includepath',
                      help="include path to search for messages",
                      action="append")
    (options, argv) = parser.parse_args(argv)

    if( not options.package or not options.outdir or len(argv) != 2):
        parser.print_help()
        exit(-1)

    generate(argv[1], options)

if __name__ == "__main__":
    generate_services(sys.argv)
    
